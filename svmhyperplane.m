function classifier = svmhyperplane(classifier)
% Finds hyperplane corresponding to linear SVM classifier
%   and generates new classifier composed of hyperplane equation
%     ax + by + cz = d
%
% To use the classifier generated by this function, apply the following:
%   classification = data*classifier(1:end-1) > classifier(end)
%     where 'data' is an N x ndims data set
%
% Inputs: classifier - SVM classifier struct (the input to svmclassify)
% Outputs: new_classifier - 1 x ndims+1 matrix of values corresponding to equation:
%   ax + by + cz = d


%% Constants

VERBOSITY = 0;          % 0: no output, 1: error measure, 2: plot
ERR = 1e-6;             % acceptable level of error as a pct of SV range
MIN_D = 0.1;            % acceptable min dist of points as pct of SV range
TIMEOUT = 1000;         % number of iterations until timeout


%% Initialize variables

% check that a linear classifier has been passed
%linear_kernel = strcmp(func2str(classifier.KernelFunction),'linear_kernel') || ...
%                (strcmp(func2str(classifier.KernelFunction),'poly_kernel') && (classifier.KernelFunctionArgs{1}==1));
%if ~linear_kernel
%    error('Classifier does not contain linear kernel');
%end

% define support vectors and groups
sv = classifier.SupportVectors;
grp = predict(classifier,sv);

% acceptable error value
err = ERR*max(std(sv));

% acceptable min separation
min_sep = MIN_D*max(std(sv));

% compute number of dimensions
ndims = size(sv,2);

% initialize point variable
p = NaN(3,ndims);


%% Iteratively find three points near hyperplane

sep = -inf;
counter = 0;
while min(sep)<min_sep && counter<=TIMEOUT
    counter = counter + 1;

    for i = 1:3

        % random initial points
        p0 = sv(randsample(find(grp==0),1),:);
        p1 = sv(randsample(find(grp==1),1),:);
        d = inf;

        % begin search
        while d>err

            % vector between points
            v = p0 - p1;

            % find midpoint
            p(i,:) = p0 - v/2;

            % classify midpoint
            warning off;
            g = predict(classifier,p(i,:));
            warning on;

            % parse classification
            if g>0
                p1 = p(i,:);
            else
                p0 = p(i,:);
            end

            % compute length of line segment
            d = sqrt(sum((v/2).^2));

        end

    end

    % ensure that point separation is high, or redo
    sep = pdist(p);
    
end


%% No solution found?

if counter>TIMEOUT
    error('No solution found');
end


%% Compute hyperplane equation from three points

% compute hyperplane: v(1)x + v(2)y + v(3)z = b
v = cross(p(1,:)-p(2,:),p(1,:)-p(3,:));
b = v*p(1,:)';

% output variable
classifier = [v b]';

% test to make sure normal vector is pointing in right direction
err_meas = sum(abs(diff([grp,sv*classifier(1:end-1)>classifier(end)],1,2)))/length(grp);
if err_meas>0.5
    classifier = -classifier;
    err_meas = sum(abs(diff([grp,sv*classifier(1:end-1)>classifier(end)],1,2)))/length(grp);
end


%% Display output

% compute error measurement using support vectors
if VERBOSITY>0
    disp(['Error = ' num2str(err_meas)]);
end
